def randomString(int length) string (
    string chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    string result = ""
    for i length (
        result = result ++ chars[rand.Intn(chars.len) + 1].toStr()
    )
    return result
)

def calculateFileHash(string path) string (
    string hash = ""
    raw("f, err := os.Open(path)")
    if err == null (
        raw("h := md5.New()")
        raw("if _, err := io.Copy(h, f); err == nil { hash = hex.EncodeToString(h.Sum(nil)) }")
        raw("f.Close()")
    )
    return hash
)

def noCORS(*gin.Context c) (
    c.Header("Access-Control-Allow-Origin", "*")
    string origin = c.GetHeader("Origin")
    if origin != "" (
        c.Header("Access-Control-Allow-Origin", origin)
        c.Header("Access-Control-Allow-Credentials", "true")
        c.Next()
        return
    )
    c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
    c.Header("Access-Control-Allow-Headers", "*")
    if c.Request.Method == "OPTIONS" (
        c.AbortWithStatus(204)
        return
    )
    c.Next()
)

def loadConfig() (
    object config = fs.ReadFile("./config.json").JsonParse().assert(object)
    authKey = config.authKey.toStr()
    useSubscriptions = config.useSubscriptions.toBool()
    subscriptionSizes = config.subscriptionSizes
    quotas = config.quotas

    if config.downscaleWhen != null (
        downscaleWhen = config.downscaleWhen
    )
)

def getAble(string userId) object (
    object profile = userData[userId]
    if profile == null (
        if fs.Exists("db/" ++ userId ++ "/user.json") (
            string data = fs.ReadFile("db/" ++ userId ++ "/user.json")
            profile = data.JsonParse().assert(object)
        ) else (
            return { canAccess: false, maxUpload: "0" }
        )
    )
    string subscription = profile.subscription.toStr().toLower()
    number quota = 0
    any maybeQuota = quotas[userId]
    if maybeQuota != null (
        quota = maybeQuota.toNum()
    ) else if useSubscriptions (
        quota = subscriptionSizes[subscription].toNum()
    )

    array images = readUserImages(userId)
    
    return {
        canAccess: (quota > 0),
        storageQuota: quota,
        hasImages: images.len > 0
    }
)

def getProfile(string username) object (
    object resp_profile = requests.Get("https://api.rotur.dev/profile?include_posts=0&name=" ++ username)
    if !resp_profile.success (
        return { ok: false, error: "failed to fetch profile" }
    )
    object profile = resp_profile.body.toStr().JsonParse()
    if profile.error != null (
        return { ok: false, error: profile.error }
    )
    return { ok: true, profile: profile }
)

def writeProfile(string userId, string username) object (
    object profileReq = getProfile(username)
    if !profileReq.ok (
        return profileReq
    )
    userData[userId] = profileReq.profile
    userIdToUsername[userId] = username
    usernameToUserId[username] = userId
    fs.MkdirAll("db/" ++ userId)
    fs.WriteFile("db/" ++ userId ++ "/user.json", profileReq.profile.toStr())
    return profileReq
)

def getUserIdFromUsername(string username) string (
    if usernameToUserId.contains(username) (
        return usernameToUserId[username].toStr()
    )
    return ""
)

def userDbPath(string userId) string (
    return "db/" ++ userId ++ "/images.json"
)

def ensureUserDb(string userId) (
    string dir = "db/" ++ userId
    if !fs.Exists(dir) (
        fs.MkdirAll(dir)
    )
    string path = userDbPath(userId)
    if !fs.Exists(path) (
        fs.WriteFile(path, "[]")
    )
    ensureCacheDir(userId)
)

def readUserImages(string userId) array (
    ensureUserDb(userId)
    string path = userDbPath(userId)
    string data = fs.ReadFile(path)
    if data == "" (
        return []
    )
    array arr = data.JsonParse()
    return arr
)

def enrichImagesWithSharing(string userId, array images) array (
    object sharesObj = readUserShares(userId)
    array shares = sharesObj.shares
    for i images.len (
        object img = images[i]
        for j shares.len (
            object share = shares[j]
            if share.imageId == img.id (
                img["sharedWith"] = share.sharedWith
                img["isPublic"] = share.isPublic
            )
        )
    )
    return images
)

def writeUserImages(string userId, array arr) boolean (
    string path = userDbPath(userId)
    string out = arr.toStr()
    return fs.WriteFile(path, out)
)

def findImage(array arr, string id) object (
    for i arr.len (
        object it = arr[i]
        if it.id == id (
            return it
        )
    )
    return {}
)

def removeImage(array arr, string id) array (
    array out = []
    for i arr.len (
        object it = arr[i]
        if it.id != id (
            out.append(it)
        )
    )
    return out
)

def removeImages(array arr, array ids) array (
    array out = []
    for i arr.len (
        object it = arr[i]
        if !ids.contains(it.id) (
            out.append(it)
        )
    )
    return out
)

def userAlbumsPath(string userId) string (
    return "db/" ++ userId ++ "/albums.json"
)

def ensureUserAlbums(string userId) (
    string dir = "db/" ++ userId
    if !fs.Exists(dir) (
        fs.MkdirAll(dir)
    )
    string path = userAlbumsPath(userId)
    if !fs.Exists(path) (
        fs.WriteFile(path, "{ \"albums\": [], \"items\": {} }")
    )
)

def readUserAlbums(string userId) object (
    ensureUserAlbums(userId)
    string path = userAlbumsPath(userId)
    string data = fs.ReadFile(path)
    if data == "" (
        return { albums: [], items: {} }
    )
    object obj = data.JsonParse()
    if obj.albums == null (
        obj.albums = []
    )
    if obj.items == null (
        obj.items = {}
    )
    return obj
)

def writeUserAlbums(string userId, object albums) boolean (
    string path = userAlbumsPath(userId)
    string out = albums.toStr()
    return fs.WriteFile(path, out)
)

def addAlbum(string userId, string name) object (
    object albums = readUserAlbums(userId)
    array list = albums.albums
    boolean exists = false
    for i list.len (
        if list[i].toStr().toLower() == name.toLower() (
            exists = true
        )
    )
    if !exists (
        list.append(name)
        albums.albums = list
    )
    if albums.items[name] == null (
        object items = albums.items
        items[name] = []
    )
    writeUserAlbums(userId, albums)
    return albums
)

def removeAlbumDef(string userId, string name) object (
    object albums = readUserAlbums(userId)
    array list = albums.albums
    array out = []
    for i list.len (
        string it = list[i].toStr()
        if it.toLower() != name.toLower() (
            out.append(it)
        )
    )
    albums.albums = out
    albums.items.delete(name)
    writeUserAlbums(userId, albums)
    return albums
)

def addImageToAlbum(string userId, string name, string id) object (
    object albums = readUserAlbums(userId)
    object items = albums.items
    if albums.items[name] == null (
        items[name] = []
    )
    array ids = items[name]
    boolean exists = false
    for i ids.len (
        if ids[i].toStr() == id (
            exists = true
        )
    )
    if !exists (
        ids.append(id)
        items[name] = ids
        writeUserAlbums(userId, albums)
    )
    return albums
)

def removeImageFromAlbum(string userId, string name, string id) object (
    object albums = readUserAlbums(userId)
    array ids = albums.items[name]
    array out = []
    for i ids.len (
        if ids[i].toStr() != id (
            out.append(ids[i])
        )
    )
    object items = albums.items
    items[name] = out
    writeUserAlbums(userId, albums)
    return albums
)

def userBinPath(string userId) string (
    return "db/" ++ userId ++ "/bin.json"
)

def ensureUserBin(string userId) (
    string dir = "db/" ++ userId
    if !fs.Exists(dir) (
        fs.MkdirAll(dir)
    )
    string path = userBinPath(userId)
    if !fs.Exists(path) (
        fs.WriteFile(path, "[]")
    )
)

def ensureCacheDir(string userId) (
    string dir = "db/" ++ userId ++ "/cache"
    if !fs.Exists(dir) (
        fs.MkdirAll(dir)
    )
)

def readUserBin(string userId) array (
    ensureUserBin(userId)
    string path = userBinPath(userId)
    string data = fs.ReadFile(path)
    if data == "" (
        return []
    )
    array arr = data.JsonParse()
    return arr
)

def writeUserBin(string userId, array arr) boolean (
    string path = userBinPath(userId)
    string out = arr.toStr()
    return fs.WriteFile(path, out)
)

def calculateStorageStats(string userId) object (
    string path = "db/" ++ userId ++ "/blob"
    if !fs.Exists(path) (
        return { totalBytes: 0, imageCount: 0, largestImages: [], binBytes: 0, duplicateGroups: [] }
    )
    array files = fs.ReadDir(path)
    number totalBytes = 0
    int imageCount = 0
    array entries = []
    object sizeGroups = {}
    
    for i files.len (
        string name = files[i].toStr()
        if name.endsWith(".jpg") (
            string fpath = path ++ "/" ++ name
            object stat = fs.GetStat(fpath)
            number size = stat.size.toNum()
            totalBytes = totalBytes + size
            imageCount = imageCount + 1
            string id = name.trim(1, -5)
            
            string sizeStr = size.toStr()
            if sizeGroups[sizeStr] == null (
                sizeGroups[sizeStr] = []
            )
            array sg = sizeGroups[sizeStr]
            sg.append({ id: id, path: fpath })
            sizeGroups[sizeStr] = sg
            
            entries.append({ id: id, bytes: size, path: fpath })
        )
    )
    
    // Detect duplicates
    object hashGroups = {}
    array duplicateGroups = []
    
    array sizeKeys = sizeGroups.getKeys()
    for i sizeKeys.len (
        string sKey = sizeKeys[i]
        array group = sizeGroups[sKey]
        if group.len > 1 (
            for j group.len (
                object it = group[j]
                string h = calculateFileHash(it.path.toStr())
                if hashGroups[h] == null (
                    hashGroups[h] = []
                )
                array hg = hashGroups[h]
                hg.append(it.id.toStr())
                hashGroups[h] = hg
            )
        )
    )
    
    array hashKeys = hashGroups.getKeys()
    for i hashKeys.len (
        string hKey = hashKeys[i]
        array group = hashGroups[hKey]
        if group.len > 1 (
            duplicateGroups.append({ hash: hKey, ids: group })
        )
    )
    
    // Sort entries by size descending
    int n = entries.len
    for i n (
        for j (n - i - 1) (
            if entries[j].bytes.toNum() < entries[j + 1].bytes.toNum() (
                object tmp = entries[j]
                entries[j] = entries[j + 1]
                entries[j + 1] = tmp
            )
        )
    )
    
    array largest = []
    int limit = 10
    if n < limit (
        limit = n
    )
    for i limit (
        largest.append({ id: entries[i].id, bytes: entries[i].bytes })
    )
    
    string binPath = "db/" ++ userId ++ "/bin"
    number binBytes = 0
    if fs.Exists(binPath) (
        array binFiles = fs.ReadDir(binPath)
        for i binFiles.len (
            string bname = binFiles[i].toStr()
            if bname.endsWith(".jpg") (
                string bfpath = binPath ++ "/" ++ bname
                object bstat = fs.GetStat(bfpath)
                binBytes = binBytes + bstat.size.toNum()
            )
        )
    )
    
    object fileSizes = {}
    for i entries.len (
        fileSizes[entries[i].id.toStr()] = entries[i].bytes
    )
    
    return {
        totalBytes: totalBytes,
        imageCount: imageCount,
        largestImages: largest,
        binBytes: binBytes,
        duplicateGroups: duplicateGroups,
        fileSizes: fileSizes
    }
)

def userSharesPath(string userId) string (
    return "db/" ++ userId ++ "/shares.json"
)

def ensureUserShares(string userId) (
    string dir = "db/" ++ userId
    if !fs.Exists(dir) (
        fs.MkdirAll(dir)
    )
    string path = userSharesPath(userId)
    if !fs.Exists(path) (
        fs.WriteFile(path, "{ \"shares\": [] }")
    )
)

def readUserShares(string userId) object (
    ensureUserShares(userId)
    string path = userSharesPath(userId)
    string data = fs.ReadFile(path)
    if data == "" (
        return { shares: [] }
    )
    object obj = data.JsonParse()
    if obj.shares == null (
        obj.shares = []
    )
    return obj
)

def writeUserShares(string userId, object sharesObj) boolean (
    string path = userSharesPath(userId)
    return fs.WriteFile(path, sharesObj.toStr())
)

def addShare(string owner, string imageId, string targetUserId) object (
    object sharesObj = readUserShares(owner)
    array shares = sharesObj.shares
    
    boolean found = false
    for i shares.len (
        object share = shares[i]
        if share.imageId.toStr() == imageId (
            array sharedWith = share.sharedWith
            boolean exists = false
            for j sharedWith.len (
                if sharedWith[j].toStr() == targetUserId (
                    exists = true
                )
            )
            if !exists (
                sharedWith.append(targetUserId)
                share.sharedWith = sharedWith
            )
            found = true
        )
    )
    
    if !found (
        shares.append({ imageId: imageId, sharedWith: [targetUserId] })
    )
    
    sharesObj.shares = shares
    writeUserShares(owner, sharesObj)
    return sharesObj
)

def removeShare(string owner, string imageId, string targetUserId) object (
    object sharesObj = readUserShares(owner)
    array shares = sharesObj.shares
    array newShares = []
    
    for i shares.len (
        object share = shares[i]
        if share.imageId.toStr() == imageId (
            array sharedWith = share.sharedWith
            array newSharedWith = []
            for j sharedWith.len (
                if sharedWith[j].toStr() != targetUserId (
                    newSharedWith.append(sharedWith[j])
                )
            )
            if newSharedWith.len > 0 (
                share.sharedWith = newSharedWith
                newShares.append(share)
            )
        ) else (
            newShares.append(share)
        )
    )
    
    sharesObj.shares = newShares
    writeUserShares(owner, sharesObj)
    return sharesObj
)

def setPublicShare(string owner, string imageId, boolean isPublic) object (
    object sharesObj = readUserShares(owner)
    array shares = sharesObj.shares
    boolean found = false
    for i shares.len (
        object share = shares[i]
        if share.imageId.toStr() == imageId (
            share["isPublic"] = isPublic
            found = true
        )
    )
    if !found and isPublic == true (
        shares.append({ imageId: imageId, sharedWith: [], isPublic: true })
    )
    sharesObj.shares = shares
    writeUserShares(owner, sharesObj)
    return sharesObj
)

def getSharedWithMe(string userId) array (
    array results = []
    string dbPath = "db"
    if !fs.Exists(dbPath) (
        return results
    )
    array dirs = fs.ReadDir(dbPath)
    for i dirs.len (
        string ownerDir = dirs[i].toStr()
        string sharesPath = dbPath ++ "/" ++ ownerDir ++ "/shares.json"
        if fs.Exists(sharesPath) (
            string data = fs.ReadFile(sharesPath)
            if data != "" (
                object sharesObj = data.JsonParse()
                array shares = sharesObj.shares
                if shares != null (
                    for j shares.len (
                        object share = shares[j]
                        array sharedWith = share.sharedWith
                        for k sharedWith.len (
                            if sharedWith[k].toStr() == userId (
                                results.append({
                                    owner: ownerDir,
                                    imageId: share.imageId
                                })
                            )
                        )
                    )
                )
            )
        )
    )
    return results
)

def getCachePath(string userId, string id) string (
    return "db/" ++ userId ++ "/cache/" ++ id ++ "_preview.jpg"
)

def servePreview(*gin.Context c, string path, string id, string username) boolean (
    if !fs.Exists(path) or fs.IsDir(path) (
        c.JSON(404, { ok: false, error: "not found" })
        return false
    )
    
    string cachePath = getCachePath(username, id)
    if fs.Exists(cachePath) (
        object cacheInfo = fs.GetStat(cachePath)
        object origInfo = fs.GetStat(path)
        
        if cacheInfo.modTime.toNum() >= origInfo.modTime.toNum() (
            string etag = "preview-" ++ cacheInfo.modTime.toStr()
            string ifNoneMatch = c.GetHeader("If-None-Match")
            if ifNoneMatch == etag (
                c.Status(304)
                return true
            )
            
            c.Header("ETag", etag)
            c.Header("Cache-Control", "private, max-age=31536000, immutable")
            c.File(cachePath)
            return true
        )
    )
    
    object fileInfo = fs.GetStat(path)
    number fileSize = fileInfo.size.toNum()
    if fileSize == 0 (
        c.JSON(404, { ok: false, error: "not found" })
        return false
    )
    if fileSize > 10000000 (
        c.JSON(413, { ok: false, error: "file too large" })
        return false
    )
    
    im := img.Open(path)
    if im == null (
        c.JSON(400, { ok: false, error: "invalid image" })
        return false
    )
    defer im.Close()
    
    number w = im.Width()
    number h = im.Height()
    number maxw = 200
    number maxh = 200
    
    if w <= maxw and h <= maxh (
        c.Header("Cache-Control", "private, max-age=31536000, immutable")
        c.File(path)
        return true
    )
    
    number ratio = min(maxw / w, maxh / h)
    int rw = round(w * ratio)
    int rh = round(h * ratio)
    
    resized := img.ResizeFast(im, rw, rh)
    if resized == null (
        c.JSON(500, { ok: false, error: "resize failed" })
        return false
    )
    defer resized.Close()
    
    boolean cached = img.SaveJPEG(resized, cachePath, 80)
    
    if cached (
        c.Header("Cache-Control", "private, max-age=31536000, immutable")
        c.File(cachePath)
    ) else (
        byte[] out = img.EncodeJPEGBytes(resized, 80)
        if out.len == 0 (
            c.JSON(500, { ok: false, error: "encode failed" })
            return false
        )
        c.Header("Cache-Control", "private, max-age=3600")
        c.Data(200, "image/jpeg", out)
    )
    
    return true
)
