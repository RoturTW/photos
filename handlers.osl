def handleAuth(*gin.Context c) (
    string token = c.Query("v")
    if token == "" (
        c.JSON(401, { ok: false, error: "missing token" })
        return
    )
    object resp = requests.Get("https://api.rotur.dev/validate?key=rotur-photos&v=" ++ token)

    if !resp.success (
        c.JSON(401, { ok: false, error: "failed to validate token" })
        return
    )

    object json = resp.body.toStr().JsonParse()
    if json.error != null (
        c.JSON(401, { ok: false, error: json.error })
        return
    )
    if !json.valid (
        c.JSON(401, { ok: false, error: "invalidate token" })
        return
    )

    string sessionId = randomString(32)
    
    string userId = json.id.toStr()
    string username = json.username.toStr()
    sessions[sessionId] = userId

    object profileReq = writeProfile(userId, username)
    if !profileReq.ok (
        c.JSON(401, profileReq.error)
        return
    )

    fs.WriteFile("db/sessions.json", sessions.JsonFormat())

    c.SetCookie("session_id", sessionId, 86400, "/", "", false, true)

    c.JSON(200, { ok: true, sessionId, token })
)

def handleLogout(*gin.Context c) (
    string sessionId = c.Cookie("session_id").toArray()[1].toStr()
    if sessionId != "" and sessions.contains(sessionId) (
        sessions.delete(sessionId)
        fs.WriteFile("db/sessions.json", sessions.JsonFormat())
    )
    c.SetCookie("session_id", "", -1, "/", "", false, true)
    c.JSON(200, { ok: true })
)

def handleAble(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    c.JSON(200, able)
)

def handleStorage(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    object stats = calculateStorageStats(userId)
    stats["quota"] = able.storageQuota
    c.JSON(200, stats)
)

def handleAllImages(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess and !able.hasImages (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    array images = readUserImages(userId)
    images = enrichImagesWithSharing(userId, images)
    c.JSON(200, images)
)

def handleRecentImages(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    array arr = readUserImages(userId)
    int n = arr.len
    number nowMs = time.Now().UnixMilli()
    number ninety = 90 * 24 * 60 * 60 * 1000
    array out = []
    for i n (
        object it = arr[i]
        number ts = it.timestamp.toNum()
        if (nowMs - ts) <= ninety (
            out.append(it)
        )
    )
    out = enrichImagesWithSharing(userId, out)
    c.JSON(200, out)
)

def handleYearImages(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    int year = c.Param("year").toNum()
    array arr = readUserImages(userId)
    int n = arr.len
    array out = []
    for i n (
        object it = arr[i]
        int ts = it.timestamp.toNum()
        t := time.UnixMilli(int64(ts))
        if t.Year() == year (
            out.append(it)
        )
    )
    out = enrichImagesWithSharing(userId, out)
    c.JSON(200, out)
)

def handleMonthImages(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    int year = c.Param("year").toNum()
    int month = c.Param("month").toNum()
    array arr = readUserImages(userId)
    int n = arr.len
    array out = []
    for i n (
        object it = arr[i]
        int ts = it.timestamp.toNum()
        t := time.UnixMilli(int64(ts))
        int tMonth = 0
        raw("tMonth = int(t.Month())")
        if t.Year() == year and tMonth == month (
            out.append(it)
        )
    )
    out = enrichImagesWithSharing(userId, out)
    c.JSON(200, out)
)

def handleUpload(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)

    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )

    string base = "db/" ++ userId ++ "/blob"
    if !fs.Exists(base) (
        fs.MkdirAll(base)
    )

    string tmpPath = base ++ "/tmp-" ++ randomString(16)
    byte[] body = c.GetRawData().toArray()[1].assert(byte[])

    if body.len == 0 (
        c.JSON(400, { ok: false, error: "empty body" })
        return
    )

    object stats = calculateStorageStats(userId)
    if (stats.totalBytes.toNum() + stats.binBytes.toNum() + body.len) > able.storageQuota.toNum() (
        c.JSON(403, { ok: false, error: "storage quota exceeded" })
        return
    )

    if !fs.WriteFile(tmpPath, body) (
        c.JSON(500, { ok: false, error: "failed to write upload" })
        return
    )

    im := img.Open(tmpPath)
    if im == null (
        fs.Remove(tmpPath)
        c.JSON(400, { ok: false, error: "invalid image" })
        return
    )

    object size = im.Size()
    int w = round(size["w"])
    int h = round(size["h"])

    if w > downscaleWhen.width or h > downscaleWhen.height (
        number ratio = min(downscaleWhen.width.toInt() / w, downscaleWhen.height.toInt() / h).toNum()

        w = round(w * ratio)
        h = round(h * ratio)

        resized := img.Resize(im, w, h)
        im.Close()

        if resized == null (
            fs.Remove(tmpPath)
            c.JSON(500, { ok: false, error: "resize failed" })
            return
        )

        im = resized
    )

    string id = randomString(24)
    string outPath = base ++ "/" ++ id ++ ".jpg"

    if !img.SaveJPEG(im, outPath, 90) (
        im.Close()
        fs.Remove(tmpPath)
        c.JSON(500, { ok: false, error: "save failed" })
        return
    )

    im.Close()

    number tsms = time.Now().UnixMilli()
    "*exif.Exif" x = null

    raw("f, err := os.Open(tmpPath)")
    if err == null (
        raw("defer f.Close()")
        raw("x, err = exif.Decode(f)")
        if err == null (
            raw("t, err := x.DateTime()")
            if err == null and !t.IsZero() (
                tsms = t.UnixMilli().toNum()
            )
        )
    )

    object entry = {
        id: id,
        width: w,
        height: h,
        timestamp: tsms,
        make: "",
        model: "",
        exposure_time: "",
        f_number: ""
    }

    if x != null (
        raw("if tag, err := x.Get(exif.Make); err == nil { entry[\"make\"], _ = tag.StringVal() }")
        raw("if tag, err := x.Get(exif.Model); err == nil { entry[\"model\"], _ = tag.StringVal() }")
        raw("if tag, err := x.Get(exif.ExposureTime); err == nil { entry[\"exposure_time\"], _ = tag.StringVal() }")
        raw("if tag, err := x.Get(exif.FNumber); err == nil { entry[\"f_number\"], _ = tag.StringVal() }")
    )
    fs.Remove(tmpPath)

    array images = readUserImages(userId)
    images.append(entry)
    writeUserImages(userId, images)

    c.JSON(200, { ok: true, id: id })
)

def handleId(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id")
    boolean json = false
    if id.endsWith(".json") (
        id = id.trim(1, -6)
        json = true
    )
    if json (
        object it = findImage(readUserImages(userId), id)
        if it.id == null (
            c.JSON(404, { ok: false, error: "not found" })
            return
        )
        c.JSON(200, it)
        return
    )
    string path = "db/" ++ userId ++ "/blob/" ++ id ++ ".jpg"
    if !fs.Exists(path) or fs.IsDir(path) (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )
    
    object fileInfo = fs.GetStat(path)
    string etag = "\"" ++ fileInfo.modTime.toStr() ++ "\""
    string ifNoneMatch = c.GetHeader("If-None-Match")
    if ifNoneMatch == etag (
        c.Status(304)
        return
    )
    
    c.Header("ETag", etag)
    c.Header("Cache-Control", "private, must-revalidate")
    c.File(path)
)

def handleImageRotate(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id")
    
    object body = c.Request.Body.toStr().JsonParse()
    number angle = body["angle"].toNum()

    string path = "db/" ++ userId ++ "/blob/" ++ id ++ ".jpg"
    if !fs.Exists(path) or fs.IsDir(path) (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )

    imgFile := img.Open(path)
    if imgFile == null (
        c.JSON(400, { ok: false, error: "invalid image" })
        return
    )
    defer imgFile.Close()

    rotated := img.Rotate(imgFile, angle)
    if rotated == null (
        c.JSON(500, { ok: false, error: "failed to rotate" })
        return
    )
    defer rotated.Close()
    
    boolean wrote = img.SaveJPEG(rotated, path, 90)
    if !wrote (
        c.JSON(500, { ok: false, error: "failed to save" })
        return
    )

    array arr = readUserImages(userId)
    object it = findImage(arr, id)
    if it.id != null (
        if angle == 90 or angle == 270 (
            number oldW = it.width.toNum()
            it.width = it.height
            it.height = oldW
            writeUserImages(userId, arr)
        )
    )

    c.JSON(200, { ok: true })
)

def handleSearch(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string q = c.Query("q").toLower()
    array arr = readUserImages(userId)
    if q == "" (
        c.JSON(200, arr)
        return
    )
    
    array months = ["january", "february", "march", "april", "may", "june", 
                    "july", "august", "september", "october", "november", "december"]
    
    object albums = readUserAlbums(userId)
    
    array out = []
    int n = arr.len
    for i n (
        object it = arr[i]
        bool match = false
        
        number ts = it.timestamp.toNum()
        if ts > 0 (
            t := time.UnixMilli(int64(ts))
            int year = t.Year()
            int month = round(t.Month())
            
            if q.contains(year.toStr()) (
                match = true
            )
            
            if month > 0 and month <= 12 (
                string monthName = months[month]
                if q.contains(monthName) (
                    match = true
                )
            )
        )
        
        string make = it.make.toStr().toLower()
        string model = it.model.toStr().toLower()
        if make != "" and q.contains(make) (
            match = true
        )
        if model != "" and q.contains(model) (
            match = true
        )
        
        object items = albums.items
        for j albums.albums.len (
            string albumName = albums.albums[j].toStr()
            if albumName.toLower().contains(q) (
                array albumIds = items[albumName]
                for k albumIds.len (
                    if albumIds[k].toStr() == it.id.toStr() (
                        match = true
                    )
                )
            )
        )
        
        if match (
            out.append(it)
        )
    )
    c.JSON(200, out)
)

def handleShareMine(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object sharesObj = readUserShares(userId)
    array shares = sharesObj.shares
    
    array images = readUserImages(userId)
    array out = []
    
    for i shares.len (
        object share = shares[i]
        string imageId = share.imageId.toStr()
        object img = findImage(images, imageId)
        if img.id != null (
            img["sharedWith"] = share.sharedWith
            out.append(img)
        )
    )
    
    c.JSON(200, out)
)

def handleShareOthers(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    array sharedWithMe = getSharedWithMe(userId)
    
    // Enrich with image data
    array results = []
    for i sharedWithMe.len (
        object item = sharedWithMe[i]
        string owner = item.owner.toStr()
        string imageId = item.imageId.toStr()
        
        array ownerImages = readUserImages(owner)
        object img = findImage(ownerImages, imageId)
        if img.id != null (
            img["owner"] = owner
            results.append(img)
        )
    )
    c.JSON(200, results)
)

def handleSharePatch(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    string imageId = c.Param("id")
    
    object body = c.Request.Body.toStr().JsonParse()
    array add = body["add"]
    array remove = body["remove"]
    
    if add == null (
        add = []
    )
    if remove == null (
        remove = []
    )
    
    for i add.len (
        string targetUsername = add[i].toStr()
        string targetUserId = getUserIdFromUsername(targetUsername)
        if targetUserId != "" (
            addShare(userId, imageId, targetUserId)
        )
    )
    for i remove.len (
        string targetUsername = remove[i].toStr()
        string targetUserId = getUserIdFromUsername(targetUsername)
        if targetUserId != "" (
            removeShare(userId, imageId, targetUserId)
        )
    )
    
    if body["isPublic"] != null (
        setPublicShare(userId, imageId, body["isPublic"].toBool())
    )
    
    c.JSON(200, { ok: true })
)

def handleShareCreate(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    
    object body = c.Request.Body.toStr().JsonParse()
    string imageId = body["imageId"].toStr()
    string targetUser = body["username"].toStr()
    
    if imageId == "" or targetUser == "" (
        c.JSON(400, { ok: false, error: "missing imageId or username" })
        return
    )
    
    array images = readUserImages(userId)
    object img = findImage(images, imageId)
    if img.id == null (
        c.JSON(404, { ok: false, error: "image not found" })
        return
    )
    
    string targetUserId = getUserIdFromUsername(targetUser)
    if targetUserId == "" (
        c.JSON(400, { ok: false, error: "user not found" })
        return
    )
    
    addShare(userId, imageId, targetUserId)
    c.JSON(200, { ok: true })
)

def handleSharedImage(*gin.Context c) (
    string ownerUsername = c.Param("owner")
    string id = c.Param("id")
    string requestingUserId = ""
    
    string sessionId = c.Cookie("session_id").toArray()[1].toStr()
    if sessionId != "" and sessions.contains(sessionId) (
        requestingUserId = sessions[sessionId].toStr()
    )
    
    string ownerId = getUserIdFromUsername(ownerUsername)
    if ownerId == "" (
        c.JSON(404, { ok: false, error: "owner not found" })
        return
    )
    
    object sharesObj = readUserShares(ownerId)
    array shares = sharesObj.shares
    bool allowed = false
    
    if requestingUserId == ownerId (
        allowed = true
    )
    
    for i shares.len (
        object share = shares[i]
        if share.imageId.toStr() == id (
            array sharedWith = share.sharedWith
            for j sharedWith.len (
                if sharedWith[j].toStr() == requestingUserId (
                    allowed = true
                )
            )
        )
    )
    
    if !allowed (
        c.JSON(403, { ok: false, error: "not authorized to view this image" })
        return
    )
    
    string path = "db/" ++ ownerId ++ "/blob/" ++ id ++ ".jpg"
    if !fs.Exists(path) (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )
    c.File(path)
)


def handleSharedImageInfo(*gin.Context c) (
    string ownerUsername = c.Param("owner")
    string id = c.Param("id")
    string requestingUserId = ""
    
    string sessionId = c.Cookie("session_id").toArray()[1].toStr()
    if sessionId != "" and sessions.contains(sessionId) (
        requestingUserId = sessions[sessionId].toStr()
    )
    
    string ownerId = getUserIdFromUsername(ownerUsername)
    if ownerId == "" (
        c.JSON(404, { ok: false, error: "owner not found" })
        return
    )
    
    object sharesObj = readUserShares(ownerId)
    array shares = sharesObj.shares
    bool allowed = false
    
    if requestingUserId == ownerId (
        allowed = true
    )
    
    for i shares.len (
        object share = shares[i]
        if share.imageId.toStr() == id (
            array sharedWith = share.sharedWith
            for j sharedWith.len (
                if sharedWith[j].toStr() == requestingUserId (
                    allowed = true
                )
            )
        )
    )
    
    if !allowed (
        c.JSON(403, { ok: false, error: "not authorized" })
        return
    )
    
    array images = readUserImages(ownerId)
    object img = findImage(images, id)
    if img.id == null (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )
    
    img["owner"] = ownerUsername
    c.JSON(200, img)
)

def handlePreview(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess and !able.hasImages (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id")
    string path = "db/" ++ userId ++ "/blob/" ++ id ++ ".jpg"
    servePreview(c, path, id, userId)
)

def handleDeleteImage(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id")
    string base = "db/" ++ userId
    string path = base ++ "/blob/" ++ id ++ ".jpg"
    string binBase = base ++ "/bin"
    if !fs.Exists(binBase) (
        fs.MkdirAll(binBase)
    )
    byte[] data = fs.ReadFileBytes(path)
    if data.len > 0 (
        imgFile := img.DecodeBytes(data)
        if imgFile != null (
            object s = imgFile.Size()
            int w = round(s.w)
            int h = round(s.h)
            resized := img.Resize(imgFile, w, h)
            if resized == null (
                c.JSON(500, { ok: false, error: "resize failed" })
                return
            )
            string binPath = binBase ++ "/" ++ id ++ ".jpg"
            bool wrote = img.SaveJPEG(resized, binPath, 90)
            if wrote (
                array binArr = readUserBin(userId)
                number tsms = time.Now().UnixMilli()
                array arr = readUserImages(userId)
                object it = findImage(arr, id)
                number origTs = it.timestamp.toNum()
                if origTs == 0 (
                    origTs = tsms
                )
                object entry = { id: id, width: w, height: h, timestamp: origTs, deletedAt: tsms }
                binArr.append(entry)
                writeUserBin(userId, binArr)
            )
        )
    )
    if fs.Exists(path) (
        fs.Remove(path)
    )
    array arr = readUserImages(userId)
    array out = removeImage(arr, id)
    writeUserImages(userId, out)
    c.JSON(200, { ok: true })
)

def handleDeleteImages(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    any ids = c.request.body.toStr().JsonParse().ids
    if ids.len == 0 (
        c.JSON(400, { ok: false, error: "missing ids" })
        return
    )
    if typeof(ids) != "array" (
        c.JSON(400, { ok: false, error: "invalid ids" })
        return
    )
    for i ids.len (
        fs.Remove("db/" ++ userId ++ "/blob/" ++ ids[i].toStr() ++ ".jpg")
    )
    array arr = readUserImages(userId)
    array out = removeImages(arr, ids.assert(array))
    writeUserImages(userId, out)
    c.JSON(200, { ok: true })
)

def handleBinList(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    array arr = readUserBin(userId)
    c.JSON(200, arr)
)

def handleBinRestore(*gin.Context c) (
    string userId = c.MustGet("userId")
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id")
    string base = "db/" ++ userId
    string binPath = base ++ "/bin/" ++ id ++ ".jpg"
    string blobPath = base ++ "/blob/" ++ id ++ ".jpg"
    imgFile := img.Open(binPath)
    if imgFile == null (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )
    defer imgFile.Close()
    object size = imgFile.Size()
    int w = round(size["w"])
    int h = round(size["h"])
    resized := img.Resize(imgFile, w, h)
    if resized == null (
        c.JSON(500, { ok: false, error: "failed to resize" })
        return
    )
    defer resized.Close()
    bool wrote = img.SaveJPEG(resized, blobPath, 90)
    if !wrote (
        c.JSON(500, { ok: false, error: "failed to restore" })
        return
    )
    array binArr = readUserBin(userId)
    array newBin = []
    number ts = time.Now().UnixMilli()
    for i binArr.len (
        object it = binArr[i]
        if it.id.toStr() != id (
            newBin.append(it)
        ) else (
            ts = it.timestamp.toNum()
        )
    )
    writeUserBin(userId, newBin)
    array arr = readUserImages(userId)
    object entry = { id: id, width: w, height: h, timestamp: ts }
    arr.append(entry)
    writeUserImages(userId, arr)
    fs.Remove(binPath)
    c.JSON(200, { ok: true })
)

def handleBinDelete(*gin.Context c) (
    string userId = c.MustGet("userId")
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id")
    string base = "db/" ++ userId
    string binPath = base ++ "/bin/" ++ id ++ ".jpg"
    if fs.Exists(binPath) (
        fs.Remove(binPath)
    )
    array binArr = readUserBin(userId)
    array newBin = []
    for i binArr.len (
        object it = binArr[i]
        if it.id.toStr() != id (
            newBin.append(it)
        )
    )
    writeUserBin(userId, newBin)
    c.JSON(200, { ok: true })
)

def handleBinEmpty(*gin.Context c) (
    string userId = c.MustGet("userId")
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    
    writeUserBin(userId, [])
    
    string base = "db/" ++ userId
    string binDir = base ++ "/bin"
    fs.Remove(binDir)
    fs.Mkdir(binDir)
    
    c.JSON(200, { ok: true })
)

def handleAlbums(*gin.Context c) (
    string userId = c.MustGet("userId")
    object able = getAble(userId)
    if !able.canAccess and !able.hasImages (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    object albums = readUserAlbums(userId)
    c.JSON(200, albums.albums)
)

def handleAlbumCreate(*gin.Context c) (
    string userId = c.MustGet("userId")
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string name = c.Query("name")
    if name == "" (
        c.JSON(400, { ok: false, error: "missing name" })
        return
    )
    object albums = addAlbum(userId, name)
    c.JSON(200, albums.albums)
)

def handleAlbumDelete(*gin.Context c) (
    string userId = c.MustGet("userId")
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string name = c.Param("name")
    object albums = removeAlbumDef(userId, name)
    c.JSON(200, albums.albums)
)

def handleAlbumImages(*gin.Context c) (
    string userId = c.MustGet("userId")
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string name = c.Param("name")
    object albums = readUserAlbums(userId)
    array ids = albums.items[name]
    array all = readUserImages(userId)
    array out = []
    for i ids.len (
        string id = ids[i].toStr()
        object it = findImage(all, id)
        if it.id != null (
            out.append(it)
        )
    )
    c.JSON(200, out)
)

def handleAlbumAdd(*gin.Context c) (
    string userId = c.MustGet("userId")
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string name = c.Param("name")
    string id = c.Query("id")
    if name == "" or id == "" (
        c.JSON(400, { ok: false, error: "missing params" })
        return
    )
    addImageToAlbum(userId, name, id)
    c.JSON(200, { ok: true })
)

def handleAlbumRemove(*gin.Context c) (
    string userId = c.MustGet("userId")
    object able = getAble(userId)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string name = c.Param("name")
    string id = c.Query("id")
    if name == "" or id == "" (
        c.JSON(400, { ok: false, error: "missing params" })
        return
    )
    removeImageFromAlbum(userId, name, id)
    c.JSON(200, { ok: true })
)

def handleBinPreview(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    object able = getAble(userId)
    if !able.canAccess and !able.hasImages (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id")
    string path = "db/" ++ userId ++ "/bin/" ++ id ++ ".jpg"
    servePreview(c, path, id, userId)
)

def handleShareInfo(*gin.Context c) (
    string userId = c.MustGet("userId").toStr()
    string imageId = c.Param("id")
    
    object sharesObj = readUserShares(userId)
    array shares = sharesObj.shares
    
    for i shares.len (
        object share = shares[i]
        if share.imageId.toStr() == imageId (
            c.JSON(200, { ok: true, sharedWith: share.sharedWith, isPublic: share.isPublic })
            return
        )
    )
    
    c.JSON(200, { ok: true, sharedWith: [] })
)

def handleDirectImage(*gin.Context c) (
    string ownerUsername = c.Param("username")
    string id = c.Param("id")
    
    string sessionId = c.Cookie("session_id").toArray()[1].toStr()
    string requestingUserId = ""
    if sessionId != "" and sessions.contains(sessionId) (
        requestingUserId = sessions[sessionId].toStr()
    )
    
    string ownerId = getUserIdFromUsername(ownerUsername)
    if ownerId == "" (
        if requestingUserId == "" (
            c.Redirect(302, "/auth")
            return
        )
        c.HTML(404, "error.html", {
            "Title": "Not Found",
            "Message": "User not found."
        })
        return
    )

    bool allowed = (ownerId == requestingUserId)
    if !allowed (
        object sharesObj = readUserShares(ownerId)
        array shares = sharesObj.shares
        for i shares.len (
            object share = shares[i]
            if share.imageId.toStr() == id (
                if share.isPublic == true (
                    allowed = true
                    break
                )
                array sharedWith = share.sharedWith
                for j sharedWith.len (
                    if sharedWith[j].toStr() == requestingUserId (
                        allowed = true
                        break
                    )
                )
                if allowed (
                    break
                )
            )
        )
    )
    
    if !allowed (
        if requestingUserId == "" (
            c.Redirect(302, "/auth")
            return
        )
        c.HTML(403, "error.html", {
            "Title": "Access Denied",
            "Message": "You don't have access to this image."
        })
        return
    )

    string path = 'db/' ++ ownerId ++ '/blob/' ++ id ++ '.jpg'
    if !fs.Exists(path) or fs.IsDir(path) (
        if requestingUserId == "" (
            c.Redirect(302, "/auth")
            return
        )
        c.HTML(404, "error.html", {
            "Title": "Not Found",
            "Message": "Image not found."
        })
        return
    )

    c.File(path)
)

