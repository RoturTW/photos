def handleAuth(*gin.Context c) (
    string token = c.Query("v")
    if token == "" (
        c.JSON(401, { ok: false, error: "missing token" })
        return
    )
    object resp = requests.Get("https://api.rotur.dev/validate?key=rotur-photos&v=" + token)

    if !resp.success (
        c.JSON(401, { ok: false, error: "failed to validate token" })
        return
    )

    object json = resp.body.toStr().JsonParse()
    if json.error != null (
        c.JSON(401, { ok: false, error: json.error })
        return
    )
    if !json.valid (
        c.JSON(401, { ok: false, error: "invalidate token" })
        return
    )

    string sessionId = randomString(32)
    
    string username = token.split(",")[1]
    sessions[sessionId] = username

    object resp_profile = requests.Get("https://api.rotur.dev/profile?include_posts=0&name=" + username)
    if !resp_profile.success (
        c.JSON(401, { ok: false, error: "failed to fetch profile" })
        return
    )
    object profile = resp_profile.body.toStr().JsonParse()
    if profile.error != null (
        c.JSON(401, { ok: false, error: profile.error })
        return
    )
    userData[username.toLower()] = profile

    fs.MkdirAll("db/" ++ username.toLower())
    fs.WriteFile("db/sessions.json", sessions.JsonFormat())
    fs.WriteFile("db/" ++ username.toLower() ++ "/user.json", profile.toStr())

    c.SetCookie("session_id", sessionId, 86400, "/", "", false, true)

    c.JSON(200, { ok: true, token: token })
)

def handleLogout(*gin.Context c) (
    string sessionId = c.Cookie("session_id").toArray()[1].toStr()
    if sessionId != "" and sessions.contains(sessionId) (
        sessions.delete(sessionId)
        fs.WriteFile("db/sessions.json", sessions.JsonFormat())
    )
    c.SetCookie("session_id", "", -1, "/", "", false, true)
    c.JSON(200, { ok: true })
)

def handleAble(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    array images = readUserImages(username)
    able["hasImages"] = images.len > 0
    c.JSON(200, able)
)

def handleStorage(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    object stats = calculateStorageStats(username)
    stats["quota"] = able.storageQuota
    c.JSON(200, stats)
)

def handleAllImages(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    array images = readUserImages(username)
    images = enrichImagesWithSharing(username, images)
    c.JSON(200, images)
)

def handleRecentImages(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    array arr = readUserImages(username)
    int n = arr.len
    number nowMs = time.Now().UnixMilli()
    number ninety = 90 * 24 * 60 * 60 * 1000
    array out = []
    for i n (
        object it = arr[i]
        number ts = it.timestamp.toNum()
        if (nowMs - ts) <= ninety (
            out.append(it)
        )
    )
    out = enrichImagesWithSharing(username, out)
    c.JSON(200, out)
)

def handleYearImages(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    int year = c.Param("year").toNum()
    array arr = readUserImages(username)
    int n = arr.len
    array out = []
    for i n (
        object it = arr[i]
        int ts = it.timestamp.toNum()
        t := time.UnixMilli(int64(ts))
        if t.Year() == year (
            out.append(it)
        )
    )
    out = enrichImagesWithSharing(username, out)
    c.JSON(200, out)
)

def handleMonthImages(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    int year = c.Param("year").toNum()
    int month = c.Param("month").toNum()
    array arr = readUserImages(username)
    int n = arr.len
    array out = []
    for i n (
        object it = arr[i]
        int ts = it.timestamp.toNum()
        t := time.UnixMilli(int64(ts))
        int tMonth = 0
        raw("tMonth = int(t.Month())")
        if t.Year() == year and tMonth == month (
            out.append(it)
        )
    )
    out = enrichImagesWithSharing(username, out)
    c.JSON(200, out)
)

def handleUpload(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string tmpBase = "db/" ++ username.toLower() ++ "/blob"
    if !fs.Exists(tmpBase) (
        fs.MkdirAll(tmpBase)
    )
    string tmpPath = tmpBase ++ "/tmp-" ++ randomString(16)
    string body = c.Request.Body.toStr()
    if body.len == 0 (
        c.JSON(400, { ok: false, error: "empty body" })
        return
    )
    
    object stats = calculateStorageStats(username)
    if (stats.totalBytes.toNum() + stats.binBytes.toNum() + body.len.toNum()) > able.storageQuota.toNum() (
        c.JSON(403, { ok: false, error: "storage quota exceeded" })
        return
    )
    bool wroteTmp = fs.WriteFile(tmpPath, body)
    if !wroteTmp (
        c.JSON(500, { ok: false, error: "failed to write upload" })
        return
    )
    string imgId = img.DecodeFile(tmpPath)
    if imgId == "" (
        c.JSON(400, { ok: false, error: "invalid image" })
        fs.Remove(tmpPath)
        return
    )
    defer img.Free(imgId)
    object size = img.Size(imgId)
    int w = round(size["w"])
    int h = round(size["h"])
    string id = randomString(24)
    string path = tmpBase ++ "/" ++ id ++ ".jpg"
    string rid = img.Resize(imgId, w, h)
    defer img.Free(rid)
    bool wrote = img.SaveJPEG(rid, path, 90)
    if !wrote (
        c.JSON(500, { ok: false, error: "failed to save" })
        fs.Remove(tmpPath)
        return
    )
    number tsms = time.Now().UnixMilli()
    "*exif.Exif" x = null
    raw("f, err := os.Open(tmpPath)")
    if err == null (
        raw("x, err = exif.Decode(f)")
        if err == null (
            raw("t0, err := x.DateTime()")
            if err == null and !t0.IsZero() (
                tsms = t0.UnixMilli().toNum()
            ) else (
                raw("tag, err := x.Get(exif.DateTimeOriginal)")
                if err == null and tag != null (
                    raw("s, err := tag.StringVal()")
                    if err == null (
                        raw("t1, err := time.Parse(\"2006:01:02 15:04:05\", s)")
                        if err == null and !t1.IsZero()  (
                            tsms = t1.UnixMilli().toNum()
                        )
                    )
                )
            )
        )
    )

    object entry = {
        id: id,
        width: w,
        height: h,
        timestamp: tsms,
        make: "",
        model: "",
        exposure_time: "",
        f_number: ""
    }

    if x != null (
        raw("if tag, err := x.Get(exif.Make); err == nil { entry[\"make\"], _ = tag.StringVal() }")
        raw("if tag, err := x.Get(exif.Model); err == nil { entry[\"model\"], _ = tag.StringVal() }")
        raw("if tag, err := x.Get(exif.ExposureTime); err == nil { entry[\"exposure_time\"], _ = tag.StringVal() }")
        raw("if tag, err := x.Get(exif.FNumber); err == nil { entry[\"f_number\"], _ = tag.StringVal() }")
    )
    fs.Remove(tmpPath)
    array arr = readUserImages(username)
    arr.append(entry)
    writeUserImages(username, arr)
    c.JSON(200, { ok: true, id: id })
)

def handleId(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id").toStr()
    boolean json = false
    if id.endsWith(".json") (
        id = id.trim(1, -6)
        json = true
    )
    if json (
        object it = findImage(readUserImages(username), id)
        if it.id == null (
            c.JSON(404, { ok: false, error: "not found" })
            return
        )
        c.JSON(200, it)
        return
    )
    string path = "db/" ++ username.toLower() ++ "/blob/" ++ id ++ ".jpg"
    if !fs.Exists(path) or fs.IsDir(path) (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )
    
    object fileInfo = fs.GetStat(path)
    string etag = "\"" ++ fileInfo.modTime.toStr() ++ "\""
    string ifNoneMatch = c.GetHeader("If-None-Match")
    if ifNoneMatch == etag (
        c.Status(304)
        return
    )
    
    c.Header("ETag", etag)
    c.Header("Cache-Control", "private, must-revalidate")
    c.File(path)
)

def handleImageRotate(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id").toStr()
    
    object body = c.Request.Body.toStr().JsonParse()
    number angle = body["angle"].toNum()

    string path = "db/" ++ username.toLower() ++ "/blob/" ++ id ++ ".jpg"
    []byte data = fs.ReadFileBytes(path)
    if data.len == 0 (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )

    string imgId = img.DecodeBytes(data)
    if imgId == "" (
        c.JSON(400, { ok: false, error: "invalid image" })
        return
    )
    defer img.Free(imgId)

    string rotatedId = img.Rotate(imgId, angle)
    if rotatedId == "" (
        c.JSON(500, { ok: false, error: "failed to rotate" })
        return
    )
    defer img.Free(rotatedId)
    
    bool wrote = img.SaveJPEG(rotatedId, path, 90)
    if !wrote (
        c.JSON(500, { ok: false, error: "failed to save" })
        return
    )

    array arr = readUserImages(username)
    object it = findImage(arr, id)
    if it.id != null (
        if angle == 90 or angle == 270 (
            number oldW = it.width.toNum()
            it.width = it.height
            it.height = oldW
            writeUserImages(username, arr)
        )
    )

    c.JSON(200, { ok: true })
)

def handleSearch(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string q = c.Query("q").toStr().toLower()
    array arr = readUserImages(username)
    if q == "" (
        c.JSON(200, arr)
        return
    )
    
    array months = ["january", "february", "march", "april", "may", "june", 
                    "july", "august", "september", "october", "november", "december"]
    
    object albums = readUserAlbums(username)
    
    array out = []
    int n = arr.len
    for i n (
        object it = arr[i]
        bool match = false
        
        number ts = it.timestamp.toNum()
        if ts > 0 (
            t := time.UnixMilli(int64(ts))
            int year = t.Year()
            int month = int(t.Month())
            
            if q.contains(year.toStr()) (
                match = true
            )
            
            if month > 0 and month <= 12 (
                string monthName = months[month]
                if q.contains(monthName) (
                    match = true
                )
            )
        )
        
        string make = it.make.toStr().toLower()
        string model = it.model.toStr().toLower()
        if make != "" and q.contains(make) (
            match = true
        )
        if model != "" and q.contains(model) (
            match = true
        )
        
        object items = albums.items
        for j albums.albums.len (
            string albumName = albums.albums[j].toStr()
            if albumName.toLower().contains(q) (
                array albumIds = items[albumName]
                for k albumIds.len (
                    if albumIds[k].toStr() == it.id.toStr() (
                        match = true
                    )
                )
            )
        )
        
        if match (
            out.append(it)
        )
    )
    c.JSON(200, out)
)

def handleShareMine(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object sharesObj = readUserShares(username)
    array shares = sharesObj.shares
    
    array images = readUserImages(username)
    array out = []
    
    for i shares.len (
        object share = shares[i]
        string imageId = share.imageId.toStr()
        object img = findImage(images, imageId)
        if img.id != null (
            img["sharedWith"] = share.sharedWith
            out.append(img)
        )
    )
    
    c.JSON(200, out)
)

def handleShareOthers(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    array sharedWithMe = getSharedWithMe(username)
    
    // Enrich with image data
    array results = []
    for i sharedWithMe.len (
        object item = sharedWithMe[i]
        string owner = item.owner.toStr()
        string imageId = item.imageId.toStr()
        
        array ownerImages = readUserImages(owner)
        object img = findImage(ownerImages, imageId)
        if img.id != null (
            img["owner"] = owner
            results.append(img)
        )
    )
    c.JSON(200, results)
)

def handleSharePatch(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    string imageId = c.Param("id")
    
    object body = c.Request.Body.toStr().JsonParse()
    array add = body["add"]
    array remove = body["remove"]
    
    if add == null (
        add = []
    )
    if remove == null (
        remove = []
    )
    
    for i add.len (
        addShare(username, imageId, add[i].toStr())
    )
    for i remove.len (
        removeShare(username, imageId, remove[i].toStr())
    )
    
    if body["isPublic"] != null (
        setPublicShare(username, imageId, body["isPublic"].toBool())
    )
    
    c.JSON(200, { ok: true })
)

def handleShareCreate(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    
    object body = c.Request.Body.toStr().JsonParse()
    string imageId = body["imageId"].toStr()
    string targetUser = body["username"].toStr()
    
    if imageId == "" or targetUser == "" (
        c.JSON(400, { ok: false, error: "missing imageId or username" })
        return
    )
    
    array images = readUserImages(username)
    object img = findImage(images, imageId)
    if img.id == null (
        c.JSON(404, { ok: false, error: "image not found" })
        return
    )
    
    addShare(username, imageId, targetUser)
    c.JSON(200, { ok: true })
)

def handleSharedImage(*gin.Context c) (
    string owner = c.Param("owner")
    string id = c.Param("id")
    string requestingUser = ""
    
    string sessionId = c.Cookie("session_id").toArray()[1].toStr()
    if sessionId != "" and sessions.contains(sessionId) (
        requestingUser = sessions[sessionId].toStr().toLower()
    )
    
    object sharesObj = readUserShares(owner)
    array shares = sharesObj.shares
    bool allowed = false
    
    if requestingUser == owner.toLower() (
        allowed = true
    )
    
    for i shares.len (
        object share = shares[i]
        if share.imageId.toStr() == id (
            array sharedWith = share.sharedWith
            for j sharedWith.len (
                if sharedWith[j].toStr().toLower() == requestingUser (
                    allowed = true
                )
            )
        )
    )
    
    if !allowed (
        c.JSON(403, { ok: false, error: "not authorized to view this image" })
        return
    )
    
    string path = "db/" ++ owner.toLower() ++ "/blob/" ++ id ++ ".jpg"
    if !fs.Exists(path) (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )
    c.File(path)
)


def handleSharedImageInfo(*gin.Context c) (
    string owner = c.Param("owner")
    string id = c.Param("id")
    string requestingUser = ""
    
    string sessionId = c.Cookie("session_id").toArray()[1].toStr()
    if sessionId != "" and sessions.contains(sessionId) (
        requestingUser = sessions[sessionId].toStr().toLower()
    )
    
    object sharesObj = readUserShares(owner)
    array shares = sharesObj.shares
    bool allowed = false
    
    if requestingUser == owner.toLower() (
        allowed = true
    )
    
    for i shares.len (
        object share = shares[i]
        if share.imageId.toStr() == id (
            array sharedWith = share.sharedWith
            for j sharedWith.len (
                if sharedWith[j].toStr().toLower() == requestingUser (
                    allowed = true
                )
            )
        )
    )
    
    if !allowed (
        c.JSON(403, { ok: false, error: "not authorized" })
        return
    )
    
    array images = readUserImages(owner)
    object img = findImage(images, id)
    if img.id == null (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )
    
    img["owner"] = owner
    c.JSON(200, img)
)


def handlePreview(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if able.canAccess == false (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id").toStr()
    string path = "db/" ++ username.toLower() ++ "/blob/" ++ id ++ ".jpg"
    if !fs.Exists(path) or fs.IsDir(path) (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )
    
    object fileInfo = fs.GetStat(path)
    string etag = "preview-" ++ fileInfo.modTime.toStr()
    string ifNoneMatch = c.GetHeader("If-None-Match")
    if ifNoneMatch == etag (
        c.Status(304)
        return
    )
    
    []byte data = fs.ReadFileBytes(path)
    if data.len == 0 (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )
    
    c.Header("ETag", etag)
    c.Header("Cache-Control", "private, must-revalidate")
    
    string imgId = img.DecodeBytes(data)
    defer img.Free(imgId)
    if imgId == "" (
        c.JSON(400, { ok: false, error: "invalid image" })
        return
    )
    object s = img.Size(imgId)
    number w = s.w.toNum()
    number h = s.h.toNum()
    number maxw = 200
    number maxh = 200
    number rw = w
    number rh = h
    if w > maxw (
        rw = maxw
        rh = h * maxw / w
    )
    if rh > maxh (
        rh = maxh
        rw = rw * maxh / rh
    )
    string rid = img.Resize(imgId, round(rw), round(rh))
    defer img.Free(rid)
    []byte out = img.EncodeJPEG(rid, 80)
    c.Data(200, "image/jpeg", out)
)

def handleDeleteImage(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id").toStr()
    string base = "db/" ++ username.toLower()
    string path = base ++ "/blob/" ++ id ++ ".jpg"
    string binBase = base ++ "/bin"
    if !fs.Exists(binBase) (
        fs.MkdirAll(binBase)
    )
    []byte data = fs.ReadFileBytes(path)
    if data.len > 0 (
        string imgId = img.DecodeBytes(data)
        defer img.Free(imgId)
        if imgId != "" (
            object s = img.Size(imgId)
            int w = round(s.w)
            int h = round(s.h)
            string rid = img.Resize(imgId, w, h)
            defer img.Free(rid)
            string binPath = binBase ++ "/" ++ id ++ ".jpg"
            bool wrote = img.SaveJPEG(rid, binPath, 90)
            if wrote (
                array binArr = readUserBin(username)
                number tsms = time.Now().UnixMilli()
                array arr = readUserImages(username)
                object it = findImage(arr, id)
                number origTs = it.timestamp.toNum()
                if origTs == 0 (
                    origTs = tsms
                )
                object entry = { id: id, width: w, height: h, timestamp: origTs, deletedAt: tsms }
                binArr.append(entry)
                writeUserBin(username, binArr)
            )
        )
    )
    if fs.Exists(path) (
        fs.Remove(path)
    )
    array arr = readUserImages(username)
    array out = removeImage(arr, id)
    writeUserImages(username, out)
    c.JSON(200, { ok: true })
)

def handleBinList(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    array arr = readUserBin(username)
    c.JSON(200, arr)
)

def handleBinRestore(*gin.Context c) (
    string username = c.MustGet("username")
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id")
    string base = "db/" ++ username.toLower()
    string binPath = base ++ "/bin/" ++ id ++ ".jpg"
    string blobPath = base ++ "/blob/" ++ id ++ ".jpg"
    []byte data = fs.ReadFileBytes(binPath)
    if data.len == 0 (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )
    string imgId = img.DecodeBytes(data)
    defer img.Free(imgId)
    if imgId == "" (
        c.JSON(400, { ok: false, error: "invalid image" })
        return
    )
    object s = img.Size(imgId)
    int w = round(s.w)
    int h = round(s.h)
    string rid = img.Resize(imgId, w, h)
    defer img.Free(rid)
    bool wrote = img.SaveJPEG(rid, blobPath, 90)
    if !wrote (
        c.JSON(500, { ok: false, error: "failed to restore" })
        return
    )
    array binArr = readUserBin(username)
    array newBin = []
    number ts = time.Now().UnixMilli()
    for i binArr.len (
        object it = binArr[i]
        if it.id.toStr() != id (
            newBin.append(it)
        ) else (
            ts = it.timestamp.toNum()
        )
    )
    writeUserBin(username, newBin)
    array arr = readUserImages(username)
    object entry = { id: id, width: w, height: h, timestamp: ts }
    arr.append(entry)
    writeUserImages(username, arr)
    fs.Remove(binPath)
    c.JSON(200, { ok: true })
)

def handleBinDelete(*gin.Context c) (
    string username = c.MustGet("username")
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id")
    string base = "db/" ++ username.toLower()
    string binPath = base ++ "/bin/" ++ id ++ ".jpg"
    if fs.Exists(binPath) (
        fs.Remove(binPath)
    )
    array binArr = readUserBin(username)
    array newBin = []
    for i binArr.len (
        object it = binArr[i]
        if it.id.toStr() != id (
            newBin.append(it)
        )
    )
    writeUserBin(username, newBin)
    c.JSON(200, { ok: true })
)

def handleBinEmpty(*gin.Context c) (
    string username = c.MustGet("username")
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    
    writeUserBin(username, [])
    
    string base = "db/" ++ username.toLower()
    string binDir = base ++ "/bin"
    fs.Remove(binDir)
    fs.Mkdir(binDir)
    
    c.JSON(200, { ok: true })
)

def handleAlbums(*gin.Context c) (
    string username = c.MustGet("username")
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    object albums = readUserAlbums(username)
    c.JSON(200, albums.albums)
)

def handleAlbumCreate(*gin.Context c) (
    string username = c.MustGet("username")
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string name = c.Query("name")
    if name == "" (
        c.JSON(400, { ok: false, error: "missing name" })
        return
    )
    object albums = addAlbum(username, name)
    c.JSON(200, albums.albums)
)

def handleAlbumDelete(*gin.Context c) (
    string username = c.MustGet("username")
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string name = c.Param("name")
    object albums = removeAlbumDef(username, name)
    c.JSON(200, albums.albums)
)

def handleAlbumImages(*gin.Context c) (
    string username = c.MustGet("username")
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string name = c.Param("name")
    object albums = readUserAlbums(username)
    array ids = albums.items[name]
    array all = readUserImages(username)
    array out = []
    for i ids.len (
        string id = ids[i].toStr()
        object it = findImage(all, id)
        if it.id != null (
            out.append(it)
        )
    )
    c.JSON(200, out)
)

def handleAlbumAdd(*gin.Context c) (
    string username = c.MustGet("username")
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string name = c.Param("name")
    string id = c.Query("id")
    if name == "" or id == "" (
        c.JSON(400, { ok: false, error: "missing params" })
        return
    )
    addImageToAlbum(username, name, id)
    c.JSON(200, { ok: true })
)

def handleAlbumRemove(*gin.Context c) (
    string username = c.MustGet("username")
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string name = c.Param("name")
    string id = c.Query("id")
    if name == "" or id == "" (
        c.JSON(400, { ok: false, error: "missing params" })
        return
    )
    removeImageFromAlbum(username, name, id)
    c.JSON(200, { ok: true })
)

def handleBinPreview(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    object able = getAble(username)
    if !able.canAccess (
        c.JSON(401, { ok: false, error: "not authorized" })
        return
    )
    string id = c.Param("id").toStr()
    string path = "db/" ++ username.toLower() ++ "/bin/" ++ id ++ ".jpg"
    []byte data = fs.ReadFileBytes(path)
    if data.len == 0 (
        c.JSON(404, { ok: false, error: "not found" })
        return
    )
    c.Header("Cache-Control", "public, max-age=31536000, immutable")
    string imgId = img.DecodeBytes(data)
    defer img.Free(imgId)
    if imgId == "" (
        c.JSON(400, { ok: false, error: "invalid image" })
        return
    )
    object s = img.Size(imgId)
    number w = s.w.toNum()
    number h = s.h.toNum()
    number maxw = 800
    number maxh = 800
    number rw = w
    number rh = h
    if w > maxw (
        rw = maxw
        rh = h * maxw / w
    )
    if rh > maxh (
        rh = maxh
        rw = rw * maxh / rh
    )
    string rid = img.Resize(imgId, round(rw), round(rh))
    defer img.Free(rid)
    []byte out = img.EncodeJPEG(rid, 80)
    c.Data(200, "image/jpeg", out)
)

def handleShareInfo(*gin.Context c) (
    string username = c.MustGet("username").toStr()
    string imageId = c.Param("id")
    
    object sharesObj = readUserShares(username)
    array shares = sharesObj.shares
    
    for i shares.len (
        object share = shares[i]
        if share.imageId.toStr() == imageId (
            c.JSON(200, { ok: true, sharedWith: share.sharedWith, isPublic: share.isPublic })
            return
        )
    )
    
    c.JSON(200, { ok: true, sharedWith: [] })
)

def handleDirectImage(*gin.Context c) (
    string owner = c.Param("username").toStr()
    string id = c.Param("id").toStr()
    
    string sessionId = c.Cookie("session_id").toArray()[1].toStr()
    string requestingUser = ""
    if sessionId != "" and sessions.contains(sessionId) (
        requestingUser = sessions[sessionId].toStr().toLower()
    )
    
    if requestingUser == "" (
        c.Redirect(302, "/auth")
        return
    )

    bool allowed = (owner.toLower() == requestingUser)
    if !allowed (
        object sharesObj = readUserShares(owner)
        array shares = sharesObj.shares
        for i shares.len (
            object share = shares[i]
            if share.imageId.toStr() == id (
                if share.isPublic == true (
                    allowed = true
                    break
                )
                array sharedWith = share.sharedWith
                for j sharedWith.len (
                    if sharedWith[j].toStr().toLower() == requestingUser (
                        allowed = true
                        break
                    )
                )
                if allowed (
                    break
                )
            )
        )
    )
    
    if !allowed (
        c.HTML(403, "error.html", {
            "Title": "Access Denied",
            "Message": "You don't have access to this image."
        })
        return
    )
    
    c.HTML(200, "index.html", {
        "Username": requestingUser,
        "Subscription": userData[requestingUser].subscription,
    })
)

